// ALL Requires
const jwt = require('jsonwebtoken');
const User = require('../models/User');
// const LoggedinUser = require('../models/LoggedinUser');
const { hash, genSalt, compare } = require('bcrypt');
const crypto = require('crypto');
const { auth } = require('../config/firebaseAdminConfig');
const sendEmail = require('../utils/sendEmail');
const { stripe } = require('../utils/stripe');
// const moment = require('moment');
// Twitter SignIn + Authorization Controller

exports.emailPasswordRegister = async (req, res) => {
  try {
    const { uid, email, displayName, password } = req.body;

    //check user by uid and email
    const existUser = await User.findOne({
      $or: [{ user_email: email }, { uid }],
    });

    //exist message for existing user
    if (existUser) {
      return res.status(400).json({
        message: `User already exist!`,
      });
    }
    const hashPass = await hash(password, await genSalt(10));
    // User Data For Database
    const userData = {
      user_email: email,
      displayName,
      uid,
      userExportCredit: 5,
      password: hashPass,
      // endDate: end_date,
      // planID: 0,
    };

    // Insert User to USER MODEL
    const user = new User(userData);
    await user.save();

    // create jwt token
    const tokenData = {
      email,
      uid,
      _id: user?.id || user?._id?.toString?.() || user?._doc?._id,
    };

    var token = jwt.sign(tokenData, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE, // expires in 365 day
    });

    res.json({
      user: userData,
      token: token,
    });
  } catch (e) {
    res.sendStatus(500);
  }
};
const otpHash = (OTP) =>
  crypto.createHash('sha256').update(OTP?.toString()).digest('hex');

exports.veriryOTPAndUpdateUser = async (req, res) => {
  try {
    const { uid, email, OTP } = req.body;

    if (!uid || !email || !OTP) {
      return res.sendStatus(400);
    }
    //check user by uid and OTP
    const OTPToken = otpHash(OTP);
    const findUser = await User.findOne({
      $and: [{ user_email: email }, { OTP: OTPToken }, { $gt: Date.now() }],
    });

    if (!findUser) {
      const again = await User.findOne({
        $and: [{ user_email: email }, { OTP: OTPToken }, { $lt: Date.now() }],
      });
      if (again) {
        await User.findOneAndUpdate(
          { user_email: email },
          {
            OTP: '',
            OTPExpiry: Date.now() - 3600,
          },
          { upsert: true }
        );
      }
    }

    if (!findUser) {
      return res.status(400).json({
        message: `invalid or expiried OTP`,
      });
    }
    let trial = (new Date().valueOf() + 604800000) / 1000; //7 day
    // const end_date = new Date(trial).toISOString().split('T')[0];
    const updateData = {
      uid,
      status: 'Active',
      OTP: '',
      OTPExpiry: null,
      endDate: Math.trunc(trial),
      planID: 0, // 0 means trial :)
      userExportCredit: 5,
    };
    const updateUser = await User.findOneAndUpdate({ email }, updateData, {
      new: true,
    });
    const userData = { ...findUser._doc, ...updateData };
    delete userData.password;
    delete userData.OTP;
    delete userData.OTPExpiry;
    delete userData.createdAt;
    delete userData.updatedAt;
    delete userData.__v;

    // create jwt token
    const tokenData = { email, uid: uid, _id: userData._id };
    const token = jwt.sign(tokenData, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE, // expires in 365 day
    });
    let stripe = { havePlan: false };
    res.json({
      stripe,
      user: userData,
      token: token,
    });
  } catch (e) {
    res.sendStatus(500);
  }
};

const generateOTP = () => {
  // Generating OTP for Client
  const OTP = crypto.randomInt(100000, 999999);
  //Generate OTP for server
  const OTPToken = crypto
    .createHash('sha256')
    .update(OTP.toString())
    .digest('hex');
  //OTP Expiry
  const OTPExpiry = Date.now() + 15 * 60 * 1000;
  return {
    OTPToken,
    OTP,
    OTPExpiry,
  };
};

exports.isExistOTPUser = async (req, res) => {
  try {
    const { email, OTP } = req.body;

    if (!email || !OTP) {
      return res.sendStatus(400);
    }

    //check user by email and OTP
    const OTPToken = otpHash(OTP);
    const user = await User.findOne({
      $and: [{ user_email: email }, { OTP: OTPToken }, { $gt: Date.now() }],
    });
    if (!user) {
      return res.status(400).json({
        message: `Invalid or expired OTP`,
      });
    }
    res.sendStatus(202);
  } catch (err) {
    res.sendStatus(500);
  }
};

exports.emailPasswordRegisterWithOTP = async (req, res) => {
  try {
    const { email, displayName, password } = req.body;

    if (!email || !displayName || !password) {
      return res.sendStatus(400);
    }
    let uid = '';
    auth()
      .getUserByEmail(email)
      .then(({ uid }) => {
        uid = uid;
      })
      .catch(() => {
        // console.log(d);
      });
    if (uid) {
      return res.status(400).json({
        message: `User already exist!`,
      });
    }
    //check user by uid and email
    const existUser = await User.findOne({
      email,
    }).exec();
    //exist message for existing user
    if (existUser) {
      return res.status(400).json({
        message: `User already exist!`,
      });
    }
    // 25,200,000 7 Days

    // User Data For Database
    const { OTPToken, OTP, OTPExpiry } = generateOTP();
    const hashPass = await hash(password, await genSalt(10));
    const userData = {
      OTPExpiry,
      OTP: OTPToken,
      email,
      displayName,
      password: hashPass,
    };
    const created = await User.create(userData);
    // console.log(created);
    const mailSend = await sendEmail(OTP, email, displayName.split(' ')?.[0]);
    if (!mailSend?.accepted) {
      return res.sendStatus(400);
    }
    res.send({
      otp: true,
      email,
    });
  } catch (e) {
    const status = e?.status || 500;
    res.status(status).json({ message: e?.message });
  }
};

exports.emailPasswordLogin = async (req, res) => {
  try {
    const { uid, email, password } = req.body;
    const existUser = await User.findOne({
      $and: [{ email }, { uid }],
    }).exec();
    // console.log(existUser);
    //exist message for existing user
    if (!existUser) {
      return res.status(400).json({
        message: `Credentials doesn't match!`,
      });
    }

    const dbPass = existUser.password;
    if (!dbPass) {
      return res.status(400).json({
        message: `Credentials doesn't match!`,
      });
    }
    const hashPass = await compare(password, dbPass);
    if (!hashPass) {
      return res.status(400).json({
        message: `Credentials doesn't match!`,
      });
    }
    // User Data For Database
    const user = { ...existUser?._doc };
    delete user.password;
    delete user.OTP;
    delete user.OTPExpiry;
    delete user.createdAt;
    delete user.updatedAt;
    delete user.__v;

    // create jwt token
    const tokenData = {
      email,
      uid,
      _id: user._id,
    };
    const token = jwt.sign(tokenData, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE, // expires in 365 day
    });
    let stripeInfo = { havePlan: false };

    if (user?.stripeCustomerId) {
      const subscriptions = await stripe.subscriptions.list(
        {
          customer: user.stripeCustomerId,
          status: 'all',
          expand: ['data.default_payment_method'],
        },
        {
          apiKey: process.env.STRIPE_SECRET_KEY,
        }
      );

      if (subscriptions?.data?.length) {
        const current_period_end = subscriptions?.data[0].current_period_end;
        stripeInfo = {
          havePlan: true,
          created: subscriptions?.data[0].created * 1000,
          current_period_start:
            subscriptions?.data[0].current_period_start * 1000,
          current_period_end: current_period_end * 1000,
          email: subscriptions?.data[0].email,
          name: subscriptions?.data[0].name,
          plan: subscriptions?.data[0].plan,
        };

        if (current_period_end > user.endDate) {
          await User.findByIdAndUpdate(
            user._id,
            {
              endDate: current_period_end,
            },
            { new: true }
          );
          user.endDate = current_period_end;
        }
      } else {
        await User.findByIdAndUpdate(user._id, {
          stripeCustomerId: '',
        });
      }
    }
    res.json({
      stripe: stripeInfo,
      user,
      token: token,
    });
  } catch (e) {
    res.sendStatus(500);
  }
};
exports.recreateToken = async (req, res) => {
  console.log('token recreating', req.user, 'ed');
  try {
    // create jwt token
    const tokenData = req.user;
    var token = jwt.sign(tokenData, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRE, // expires in 50 mins
    });
    res.json({
      token: token,
      isSuccess: true,
    });
  } catch (e) {
    res.sendStatus(500);
  }
};
